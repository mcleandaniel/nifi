process_group:
  name: NiFi Flow
  process_groups:
    - name: Tools_Trust_Inspect_HTTP
      description: |
        Inspect a dedicated truststore via HTTP trigger. Query params: name, type (default JKS), pass.
        Flow: HandleHttpRequest (/tools/trust/inspect) → ExtractText (params) → UpdateAttribute (defaults) →
        ExecuteScript (Java KeyStore list) → HandleHttpResponse (200).
      processors:
        - id: http-req
          name: HandleHttpRequest
          type: org.apache.nifi.processors.standard.HandleHttpRequest
          properties:
            Listening Port: "18081"
            Allowed Paths: "/tools/trust/inspect"
            HTTP Context Map: http-context-map
        - id: inject
          name: Inject Key
          type: org.apache.nifi.processors.attributes.UpdateAttribute
          properties:
            tools.expected.key: SET_BY_CLI
        - id: auth
          name: Auth (Groovy)
          type: org.apache.nifi.processors.script.ExecuteScript
          properties:
            Script Engine: Groovy
            Script Body: |
              import java.nio.charset.StandardCharsets
              def ff = session.get(); if(!ff) return
              def got = ff.getAttribute('http.headers.X-Tools-Key') ?: ''
              def exp = ff.getAttribute('tools.expected.key') ?: ''
              if(got != exp){
                ff = session.putAttribute(ff,'http.status','401')
                ff = session.write(ff){ os -> os.write('Unauthorized'.getBytes(StandardCharsets.UTF_8)) }
                session.transfer(ff, REL_FAILURE)
              } else {
                session.transfer(ff, REL_SUCCESS)
              }
        # Prepare/parse query in shell instead of NiFi processors; pass http.query.string via env
        - id: parse
          name: Parse Query (Groovy)
          type: org.apache.nifi.processors.script.ExecuteScript
          properties:
            Script Engine: Groovy
            Script Body: |
              def ff = session.get(); if(!ff) return
              def qs = ff.getAttribute('http.query.string') ?: ''
              def params = [:]
              qs.split('&').each { p -> if(p){ def parts=p.split('=',2); def k=parts[0]; def v=parts.length>1?java.net.URLDecoder.decode(parts[1],'UTF-8'):''; params[k]=v } }
              def name=params['name']?:''; def type=(params['type']?:'JKS').toUpperCase(); def pass=params['pass']?:''
              ff = session.putAllAttributes(ff, ['ts.name':name,'ts.type':type,'ts.pass':pass])
              session.transfer(ff, REL_SUCCESS)
        - id: run
          name: Run (Groovy inspect JSON)
          type: org.apache.nifi.processors.script.ExecuteScript
          properties:
            Script Engine: Groovy
            Script Body: |
              import java.nio.charset.StandardCharsets
              import java.security.KeyStore
              import java.security.MessageDigest
              import groovy.json.JsonOutput
              def ff = session.get(); if(!ff) return
              def dir = new File('/opt/nifi/nifi-current/conf/truststores'); dir.mkdirs()
              def name = ff.getAttribute('ts.name')?:''
              def type = (ff.getAttribute('ts.type')?:'PKCS12').toUpperCase()
              def pass = ff.getAttribute('ts.pass')?:''
              def ext = type=='JKS'?'jks': (['PKCS12','P12'].contains(type)?'p12': (type=='BCFKS'?'bcfks':'p12'))
              def trust = new File(dir, name + '.' + ext)
              def entries = []
              int status = 200
              try {
                if(trust.exists()){
                  def ks = KeyStore.getInstance(type)
                  new FileInputStream(trust).withCloseable { ks.load(it, pass.toCharArray()) }
                  def en = ks.aliases()
                  while(en.hasMoreElements()){
                    def a = en.nextElement()
                    def cert = ks.getCertificate(a)
                    def x = (cert instanceof java.security.cert.X509Certificate) ? cert : null
                    def md = MessageDigest.getInstance('SHA-256')
                    def fp = md.digest(cert.getEncoded()).collect{ String.format('%02X', it) }.join(':')
                    def subj = x ? x.getSubjectX500Principal().getName() : ''
                    def iss = x ? x.getIssuerX500Principal().getName() : ''
                    def nb = x ? x.getNotBefore().getTime() : null
                    def na = x ? x.getNotAfter().getTime() : null
                    entries.add([alias:a, subject:subj, issuer:iss, notBefore:nb, notAfter:na, sha256:fp])
                  }
                } else {
                  status = 404
                }
              } catch(Exception ex){ status=500 }
              def json = JsonOutput.toJson([store:name, type:type, file:trust.absolutePath, entries:entries])
              ff = session.write(ff){ os -> os.write(json.getBytes(StandardCharsets.UTF_8)) }
              ff = session.putAttribute(ff,'http.status', String.valueOf(status))
              session.transfer(ff, REL_SUCCESS)
        - id: http-resp
          name: HandleHttpResponse
          type: org.apache.nifi.processors.standard.HandleHttpResponse
          properties:
            HTTP Status Code: "${http.status}"
            Content-Type: application/json
            HTTP Context Map: http-context-map
      connections:
        - source: http-req
          destination: inject
          relationships: [success]
        - source: inject
          destination: auth
          relationships: [success]
        - source: auth
          destination: parse
          relationships: [success]
        - source: auth
          destination: http-resp
          relationships: [failure]
        - source: parse
          destination: run
          relationships: [success]
        - source: run
          destination: http-resp
          relationships: [success]
