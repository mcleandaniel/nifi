#!/usr/bin/env python3
import os
import re
import subprocess
import sys
from pathlib import Path
from typing import Match, Optional

FLAGS_REQUIRING_VALUE = {
    "model",
    "m",
    "profile",
    "p",
    "sandbox",
    "s",
    "output-schema",
    "output-last-message",
    "o",
    "color",
    "cd",
    "C",
    "config",
    "c",
    "image",
    "i",
}

NAMED_PLACEHOLDER_RE = re.compile(r"\$[A-Z][A-Z0-9_]*")
CURLY_PLACEHOLDER_RE = re.compile(r"\{\{\s*([A-Za-z0-9_]+)\s*\}\}")


def codex_home() -> Path:
    home_override = os.environ.get("CODEX_HOME")
    if home_override:
        return Path(home_override).expanduser()
    return Path.home() / ".codex"


def resolve_template_path(raw: str) -> Path:
    candidate = Path(raw).expanduser()
    if candidate.is_file():
        return candidate

    name = raw.strip()
    if name.startswith("/"):
        name = name.lstrip("/")

    if ":" in name:
        name = name.split(":", 1)[1]

    if not name.endswith(".md"):
        name = f"{name}.md"

    return codex_home() / "prompts" / name


def strip_front_matter(content: str) -> str:
    lines = content.splitlines(keepends=True)
    if not lines:
        return content

    if lines[0].strip() != "---":
        return content

    for idx, line in enumerate(lines[1:], start=1):
        if line.strip() == "---":
            body = "".join(lines[idx + 1:])
            return body.lstrip("\r\n")

    return content


def substitute_positional_args(template: str, args: list[str]) -> str:
    sentinel = "__CODXPROMPT_LITERAL_DOLLAR__"
    text = template.replace("$$", sentinel)

    for index in range(1, 10):
        placeholder = f"${index}"
        if placeholder in text:
            try:
                replacement = args[index - 1]
            except IndexError as exc:
                raise ValueError(f"Missing value for {placeholder}") from exc
            text = text.replace(placeholder, replacement)

    if "$ARGUMENTS" in text:
        text = text.replace("$ARGUMENTS", " ".join(args))

    return text.replace(sentinel, "$")


def load_template(path: Path) -> str:
    try:
        raw = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        raise FileNotFoundError(f"Prompt template not found: {path}") from None
    return strip_front_matter(raw)


def split_prompt_arguments(tokens: list[str]) -> tuple[list[str], dict[str, str]]:
    positional: list[str] = []
    named: dict[str, str] = {}
    for token in tokens:
        if "=" in token and not token.startswith("="):
            key, value = token.split("=", 1)
            key = key.strip()
            if key:
                named[key] = value
                continue
        positional.append(token)
    return positional, named


def resolve_named_value(named: dict[str, str], key: str) -> Optional[str]:
    if key in named:
        return named[key]
    lowered = key.lower()
    if lowered in named:
        return named[lowered]
    uppered = key.upper()
    if uppered in named:
        return named[uppered]
    return None


def substitute_named_placeholders(template: str, named: dict[str, str]) -> str:
    missing: set[str] = set()

    def replacer(match: Match[str]) -> str:
        start = match.start()
        if start > 0 and template[start - 1] == "$":
            return match.group(0)
        key = match.group(0)[1:]
        if key == "ARGUMENTS":
            return match.group(0)
        value = resolve_named_value(named, key)
        if value is None:
            missing.add(key)
            return match.group(0)
        return value

    replaced = NAMED_PLACEHOLDER_RE.sub(replacer, template)
    if missing:
        keys = ", ".join(sorted(missing))
        raise ValueError(f"Missing named arguments: {keys}")
    return replaced


def substitute_curly_placeholders(template: str, named: dict[str, str]) -> str:
    missing: set[str] = set()

    def replacer(match: Match[str]) -> str:
        key = match.group(1)
        value = resolve_named_value(named, key)
        if value is None:
            missing.add(key)
            return match.group(0)
        return value

    replaced = CURLY_PLACEHOLDER_RE.sub(replacer, template)
    if missing:
        keys = ", ".join(sorted(missing))
        raise ValueError(f"Missing named arguments: {keys}")
    return replaced


def print_help() -> None:
    help_text = """Render a Codex prompt file, expand $1…$9 placeholders, then run `codex exec`.

Usage:
  codexprompt [codex-flags] [--] TEMPLATE [prompt-args...]
  codexprompt --print-only [--] TEMPLATE [prompt-args...]

Options:
  --print-only        Only render the template text and write it to stdout.
  -h, --help          Show this message.

Arguments:
  TEMPLATE            Prompt name (e.g. weather-town) or path to a .md file.
  prompt-args...      Positional values for $1, $2… or key=value pairs for $NAME / {{name}}.

Codex flags:
  Any flags placed before TEMPLATE (e.g. --search, --model gpt-5, -c foo=bar,
  --cd <DIR>) are forwarded directly to the `codex` binary before `exec`.
  Use `--` if the template name might be mistaken for a flag.

Examples:
  codexprompt weather-polegate
    → runs `codex exec "What is the current weather in Polegate, United Kingdom?"`

  codexprompt --search weather-town "Brighton"
    → runs `codex --search exec "What is the current weather in Brighton, United Kingdom?"`

  codexprompt research-assistant research_request="NiFi CLI back-referencing"
    → fills {{research_request}} / $RESEARCH_REQUEST and runs `codex exec …`.

  codexprompt --print-only weather-town "Brighton"
    → prints the rendered prompt without invoking codex.

  codexprompt --cd . -- research-assistant "$(cat draft.md)" > output.md
    → forwards `--cd .` to codex, renders the `research-assistant` template with
      the file contents substituted, and writes the final text to output.md.
"""
    print(help_text)


def main() -> int:
    argv = sys.argv[1:]

    if not argv:
        print_help()
        return 1

    print_only = False
    filtered: list[str] = []
    for arg in argv:
        if arg == "--print-only":
            print_only = True
        else:
            filtered.append(arg)
    argv = filtered

    if "-h" in argv or "--help" in argv:
        print_help()
        return 0
    argv = [arg for arg in argv if arg not in ("-h", "--help")]

    if not argv:
        print("codexprompt: missing template argument", file=sys.stderr)
        return 1

    codex_args: list[str] = []
    idx = 0
    while idx < len(argv):
        token = argv[idx]
        if token == "--":
            idx += 1
            break
        if token.startswith("-"):
            codex_args.append(token)
            if "=" in token:
                idx += 1
                continue
            flag_name = token.lstrip("-")
            if flag_name in FLAGS_REQUIRING_VALUE:
                idx += 1
                if idx >= len(argv):
                    print(f"codexprompt: missing value for flag {token}", file=sys.stderr)
                    return 1
                codex_args.append(argv[idx])
                idx += 1
                continue
            idx += 1
            continue
        break

    if idx >= len(argv):
        print("codexprompt: missing template argument", file=sys.stderr)
        return 1

    template_arg = argv[idx]
    prompt_args = argv[idx + 1 :]

    template_path = resolve_template_path(template_arg)
    body = load_template(template_path)

    positional_args, named_args = split_prompt_arguments(prompt_args)

    try:
        rendered = substitute_named_placeholders(body, named_args)
        rendered = substitute_curly_placeholders(rendered, named_args)
    except ValueError as exc:
        print(f"codexprompt: {exc}", file=sys.stderr)
        return 1

    try:
        rendered = substitute_positional_args(rendered, positional_args)
    except ValueError as exc:
        print(f"codexprompt: {exc}", file=sys.stderr)
        return 1

    if print_only:
        sys.stdout.write(rendered)
        if not rendered.endswith("\n"):
            sys.stdout.write("\n")
        return 0

    command = ["codex", *codex_args, "exec", rendered]
    result = subprocess.run(command)
    return result.returncode


if __name__ == "__main__":
    sys.exit(main())
